const { EmbedBuilder: d } = require("@discordjs/builders"), { CDN: e } = require("@discordjs/rest"), { Client: b, Intents: a, MessageEmbed: f, InteractionWebhook: g } = require("discord.js"), { Permissions: h } = require("discord.js"), { guildId: i, token: c } = require("./config.json"), client = new b({ intents: [a.FLAGS.GUILDS, a.FLAGS.GUILD_MESSAGES, a.FLAGS.GUILD_BANS, a.FLAGS.GUILD_MEMBERS, a.FLAGS.GUILD_PRESENCES] }), gitLink = "https://github.com/isaacmaddox/Discord-Bot"; let mutedUsers = []; const commands = [",1", ",2", ",ban", ",unban", ",mute", ",unmute", ",kick", ",help", ",warn", ",report", ",appeal", ",clear", ",close", ",delete", ",invite", ",potato", ",p", ",git"], modCmds = [",ban", ",unban", ",mute", ",unmute", ",kick", ",warn", ",clear", ",close", ",delete"]; let warns = [], muteTimes = []; const insults = ["silly", "stupid", "crazy", "bozo", "idiot", "stoopid", "idot", "bonehead", "dummy"]; let potato = { currentUser: null, previousUser: null, timer: null }, potatoHead = "", potatoTimer, ableToPlay = !0, potatoChannel = ""; const staffRole = "989022886801072169", muteRole = "989021549438861322", logs = "989021730469191750", welcomeChannel = "989022003040243723", inviteLink = "https://discord.gg/8NMyWPgNnX", reportsCategory = "989027542428184666", potatoRole = "989727856110235658"; function ban(a) { let b = a.content.replace(",ban ", "").split(" "), c = b[0].replace("<@", "").replace(">", ""), d = "No reason given"; if (!a.guild.members.cache.get(c)) { a.reply({ embeds: [buildEmbed("#2F3136", "I could not find that user.", "", [], null, !0)] }); return } if (c === a.author.id) { a.reply({ embeds: [buildEmbed("#2F3136", `You can't ban yourself, ${insults[Math.floor(Math.random() * insults.length)]}.`, "", [], null, !0)] }); return } if (a.guild.members.cache.get(c).roles.cache.get(staffRole)) { a.reply({ embeds: [buildEmbed("#2F3136", "You can't ban staff members", "", [], null, !0)] }); return } if (b[1] && b[2]) { d = b[1]; for (var e = 2; e < b.length; e++)d += " " + b[e] } else b[1] && (d = b[1]); a.guild.members.cache.get(c).send({ embeds: [buildEmbed("#da1212", "You have been banned.", `${a.author.tag} banned you`, [{ name: "Reason", value: d },], { text: "Message Isaac.#0005 for help." }, !1)] }).catch(() => { }), setTimeout(() => { a.guild.members.cache.get(c).ban({ reason: d }).then(() => { client.channels.cache.get(logs).send({ embeds: [buildEmbed("#da1212", `Event: Ban (${c})`, `<@${c}> banned`, [{ name: "Reason", value: d }, { name: "Moderator", value: a.author.tag }], { text: "xOvermod by Isaac Maddox. ,help" }, !1)] }), a.reply({ embeds: [buildEmbed("#2F3136", `Banned ${c}`, "", [], null, !0)] }).catch(a => { console.log(a) }) }).catch(b => { a.reply({ embeds: [buildEmbed("#2F3136", "Cannot ban this user", "", [], null, !0)] }).catch(a => { console.log(a) }) }) }, 500) } function unban(a) { let b = a.content.replace(",unban ", "").split(" ")[0].replace("<@", "").replace(">", ""); a.guild.members.unban(b).then(() => { a.guild.channels.cache.get(logs).send({ embeds: [buildEmbed("#20add8", `Event: Unban (${b})`, `<@${b}> unbanned`, [{ name: "Moderator", value: a.author.tag }], { text: "xOvermod by Isaac Maddox. ,help" }, !1)] }), a.reply({ embeds: [buildEmbed("#2F3136", `Unbanned ${b}`, "", [], null, !0)] }) }).catch(c => { a.reply({ embeds: [buildEmbed("#2F3136", `Invalid user ID: ${b}`, "", [], null, !0)] }), console.log(c) }) } function kick(a) { let b = a.content.replace(",kick ", "").split(" ")[0].replace("<@", "").replace(">", ""), c = a.content.substring(a.content.indexOf(b) + b.length + 2, a.content.length); if (("" == c || " " == c) && (c = "No reason given."), b === a.author.id) { a.reply({ embeds: [buildEmbed("#2F3136", `You can't kick yourself, ${insults[Math.floor(Math.random() * insults.length)]}`, "", [], null, !0)] }); return } try { a.guild.members.cache.get(b).send({ embeds: [buildEmbed("#da1212", "You have been kicked", `${a.author.tag} kicked you`, [{ name: "Reason", value: `${c}` },], { text: "Message Isaac.#0005 for help" })] }).catch(() => { }) } catch { console.log("e") } setTimeout(() => { a.guild.members.cache.get(b).kick({ reason: c }).then(() => { a.guild.channels.cache.get("logs").send({ embeds: [buildEmbed("#da1212", "Event: Kick", `${b} kicked`, [{ name: "Reason", value: `${c}` }, { name: "Moderator", value: a.author.tag }], { text: "xOvermod by Isaac Maddox. ,help" })] }), a.reply({ embeds: [buildEmbed("#2F3136", `Kicked member: ${c}`, `<@${b}> kicked`, [], null, !0)] }) }) }, 500) } function mute(a) { let b = a.content.replace(",mute ", "").split(" "), d = b[0].replace("<@", "").replace(">", ""), f = "", e = "No reason given", c; if (!a.guild.members.cache.get(d)) { a.reply({ embeds: [buildEmbed("#2F3136", "I couldn't find that user", "", [], null, !0)] }); return } if (a.guild.members.cache.get(d).roles.cache.get(muteRole)) { a.reply({ embeds: [buildEmbed("#2F3136", "User is already muted", "", [], null, !0)] }); return } if (d === a.author.id) { a.reply({ embeds: [buildEmbed("#2F3136", `You can't mute yourself, ${insults[Math.floor(Math.random() * insults.length)]}`, "", [], null, !0)] }); return } if (a.guild.members.cache.get(d).roles.cache.get(staffRole)) { a.reply({ embeds: [buildEmbed("#2F3136", "You can't mute a staff member", "", [], null, !0)] }); return } if (b[1] && /[0-9]+[smh]/.test(b[1])) { switch (c = parseInt(b[1].substring(0, b[1].length - 1)), b[1][b[1].length - 1]) { case "s": f = `${c} second${c > 1 ? "s" : ""}`, c *= 1e3; break; case "m": f = `${c} minute${c > 1 ? "s" : ""}`, c *= 6e4; break; case "h": f = `${c} hour${c > 1 ? "s" : ""}`, c *= 36e5 }b[2] && (e = a.content.substring(a.content.indexOf(b[1]) + b[1].length + 1, a.content.length)) } else b[1] && (e = a.content.substring(a.content.indexOf(b[1]), a.content.length)); if (a.guild.members.cache.get(d).roles.add(muteRole), mutedUsers.push(d), c) { let g = setTimeout(() => { unmute(d) }, c); var h = new muteTimer(g, d); muteTimes.push(h), a.guild.channels.cache.get(logs).send({ embeds: [buildEmbed("#da1212", `Event: Mute (${d}`, `<@${d}> muted`, [{ name: "Duration", value: f }, { name: "Reason", value: e }, { name: "Moderator", value: a.author.tag }], { text: "xOvermod by Isaac Maddox. ,help" }, !1)] }), a.reply({ embeds: [buildEmbed("#2F3136", `User muted for ${f}: ${e}`, "", [], null, !0)] }).catch(a => { console.log(a) }) } else a.guild.channels.cache.get(logs).send({ embeds: [buildEmbed("#da1212", `Event: Mute (${d})`, `<@${d}> muted`, [{ name: "Reason", value: e }, { name: "Moderator", value: a.author.tag }], { text: "xOvermod by Isaac Maddox. ,help" }, !1)] }), a.reply({ embeds: [buildEmbed("#2F3136", `User muted: ${e}`, "", [], null, !0)] }).catch(a => { console.log(a) }) } function unmute(a) { if ("string" == typeof a) { let b = a; if (client.guilds.cache.get(i).members.cache.get(b)) { if (!client.guilds.cache.get(i).members.cache.get(b).roles.cache.get(muteRole)) { a.reply({ embeds: [buildEmbed("#2F3136", "User is not muted.", "", [], null, !0)] }); return } client.guilds.cache.get(i).members.cache.get(b).roles.remove(muteRole); var c = muteTimes.find(a => a.user === b), f = muteTimes.indexOf(c); muteTimes.splice(f, 1), f = mutedUsers.indexOf(b), mutedUsers.splice(f, 1), client.guilds.cache.get(i).channels.cache.get(logs).send({ embeds: [buildEmbed("#20add8", `Event: Unmute (${b})`, `<@${b}> unmuted (Automatic)`, [{ name: "Moderator", value: "xOvermod#3621" }], { text: "xOvermod by Isaac Maddox. ,help" }, !1)] }) } } else { let d = a.content.replace(",unmute ", "").split(" ")[0].replace("<@", "").replace(">", ""); a.guild.members.cache.get(d).roles.remove(muteRole); var c = muteTimes.find(a => a.user === d); let e; c && (e = muteTimes.indexOf(c), clearTimeout(c.timer), muteTimes.splice(e, 1)), e = mutedUsers.indexOf(d), mutedUsers.splice(e, 1), client.guilds.cache.get(i).channels.cache.get(logs).send({ embeds: [buildEmbed("#20add8", `Event: Unmute (${d})`, `<@${d}> unmuted`, [{ name: "Moderator", value: a.author.tag }], { text: "xOvermod by Isaac Maddox. ,help" }, !1)] }), a.reply({ embeds: [buildEmbed("#2F3136", "Unmuted user", `<@${d}> unmuted`, [], null, !0)] }).catch(a => { console.log(a) }) } } function warn(a) { let d = a.content.replace(",warn ", "").split(" "), c = d[0].replace("<@", "").replace(">", ""), l = a.author.tag; if ("list" == c) { let e; if (d[1]) e = d[1].replace("<@", "").replace(">", "") || void 0; else { help("warn-list", a); return } if (!a.guild.members.cache.get(e)) { a.reply({ embeds: [buildEmbed("#2F3136", "This user does not exist in this guild", "", [], null, !0)] }); return } let h = warns.find(a => a.id === e); if (!h) { a.reply({ embeds: [buildEmbed("#2F3136", "This user does not have any warnings", "", [], null, !0)] }); return } e = a.guild.members.cache.get(e); let k = buildEmbed("#E49700", `${e.user.tag}'s warnings:`, "", [], null, !0); for (var f = 0; f < h.messages.length; f++)k.addField(`Warning ${f + 1}`, `${h.messages[f].mod} - ${h.messages[f].msg}`); a.reply({ embeds: [k] }); return } if ("remove" == c) { let m, i; if (d[1] && parseInt(d[2]) > 0) m = d[1].replace("<@", "").replace(">", ""), i = d[2] - 1; else if (d[1]) { if (d[1] && !d[2]) { a.reply({ embeds: [buildEmbed("#2F3136", "Please enter a warning to remove", "", [], null, !0)] }); return } if (isNaN(parseInt(d[2])) || 1 > parseInt(d[2])) { a.reply({ embeds: [buildEmbed("#2F3136", "Please enter a valid index (positive non-zero integer)", "", [], null, !0)] }); return } } else { help("warn-remove", a); return } if (!a.guild.members.cache.find(a => a.id === m)) { a.reply({ embeds: [buildEmbed("#2F3136", "This user does not exist in this guild", "", [], null, !0)] }); return } if (!warns.find(a => a.id === m)) { a.reply({ embeds: [buildEmbed("#2F3136", "This user does not have any warnings", "", [], null, !0)] }); return } let j = warns.find(a => a.id === m).messages; if (a.reply({ embeds: [buildEmbed("#2F3136", "Removed warning:", "", [{ name: "Warning", value: `${j[i].mod} - ${j[i].msg}` }], null, !0)] }), j.splice(i, 1), 0 == j.length) { let n = warns.find(a => a.id === m); warns.splice(n, 1) } return } let g; if (d[1] && (g = a.content.trim().substring(a.content.indexOf(d[1]), a.content.length)), "" == g && (g = "No reason given"), c === a.author.id) { a.reply({ embeds: [buildEmbed("#2F3136", `You can't warn yourself, ${insults[Math.floor(Math.random() * insults.length)]}`, "", [], null, !0)] }); return } if (a.guild.members.cache.get(c).roles.cache.get(staffRole)) { a.reply({ embeds: [buildEmbed("#2F3136", "You can't warn a staff member", "", [], null, !0).addField("Test", "testing")] }); return } let b = warns.find(a => a.id === c); if (!b) { let o = new User(c); warns.push(o), b = warns[warns.length - 1] } let p = new warnMsg(l, g); b.messages.push(p), c = a.guild.members.cache.get(c), a.reply({ embeds: [buildEmbed("#2F3136", `Warned ${c.user.tag}: ${g}`, "", [], null, !0)] }), c = c.id, 1 == b.messages.length ? a.guild.members.cache.get(c).send({ embeds: [buildEmbed("#E49700", "Warning", "You have received a warning. Your third warning will result in an hour-long mute, and your fourth warning will result in a ban", [{ name: "Warning Message", value: b.messages[0].msg }, { name: "Moderator", value: b.messages[0].mod },], { text: "Message Isaac.#0005 or another staff member for help" })] }) : 3 == b.messages.length ? (a.guild.members.cache.get(c).send({ embeds: [buildEmbed("#da1212", "Auto-Mute", "You have been automatically muted for hitting 3 warnings. Another warning will result in a ban.", [{ name: "Warning 1", value: b.messages[0].mod + " - " + b.messages[0].msg }, { name: "Warning 2", value: b.messages[1].mod + " - " + b.messages[1].msg }, { name: "Warning 3", value: b.messages[2].mod + " - " + b.messages[2].msg },], { text: "Message Isaac.#0005 or another staff member for help" })] }), a.content = `,mute ${c} 1h 3 Warnings`, a.author = client.user, mute(a)) : 4 == b.messages.length && (a.guild.members.cache.get(c).send({ embeds: [buildEmbed("#da1212", "Auto-Ban", "You have been automatically banned from xOvergang for hitting 4 warnings", [{ name: "Warning 1", value: b.messages[0].mod + " - " + b.messages[0].msg }, { name: "Warning 2", value: b.messages[1].mod + " - " + b.messages[1].msg }, { name: "Warning 3", value: b.messages[2].mod + " - " + b.messages[2].msg }, { name: "Warning 4", value: b.messages[3].mod + " - " + b.messages[3].msg },], { text: "Message Isaac.#0005 for help" })] }), a.content = `,ban ${c} 4 Warnings`, a.author = client.user, ban(a)) } function invite(a) { a.send("https://discord.gg/8NMyWPgNnX") } async function clear(a, d, c) { d?.delete(); let b = { size: 1 }; for (; 0 != b.size;)b = await a.messages.fetch({ limit: 100 }), a.bulkDelete(b).catch(a => { console.log(a) }); a.send({ embeds: [buildEmbed("#2F3136", `${c} cleared this channel`, "", [], null, !0)] }).then(a => { setTimeout(() => { a.delete() }, 3e3) }), client.guilds.cache.get(i).channels.cache.get(logs).send({ embeds: [buildEmbed("#20add8", `${a.name} cleared`, `${c} cleared ${a.name}`, [], { text: "xOvermod by Isaac Maddox. ,help" }, !1)] }) } function del(a) { let b = Math.floor(parseInt(a.content.substring(7, a.content.length))); if (!b || b == NaN) { a.reply({ embeds: [buildEmbed("#2F3136", "Please provide a valid number of messages to delete (1-100)", "", [], null, !0)] }); return } b > 99 && (b = 99), a.channel.bulkDelete(b + 1).then(() => { a.channel.send({ embeds: [buildEmbed("#2F3136", `Deleted ${b} messages.`, "", [], null, !0)] }).then(a => { setTimeout(() => { a.delete() }, 3e3) }) }).catch(() => { a.channel.send({ embeds: [buildEmbed("#2F3136", "Unable to delete messages", "", [], null, !0)] }) }), a.guild.channels.cache.get(logs).send({ embeds: [buildEmbed("#20add8", `messages deleted in ${a.channel.name}.`, `${a.author.tag} deleted ${b} messages.`, [], { text: "xOvermod by Isaac Maddox. ,help" }, !1)] }) } function appeal(a) { a.guild.channels.create(`${a.author.tag}-appeal`, { type: "text", parent: reportsCategory, permissionOverwrites: [{ id: a.guild.roles.everyone, deny: ["VIEW_CHANNEL"] }, { id: a.author.id, allow: ["VIEW_CHANNEL"] }, { id: staffRole, allow: ["VIEW_CHANNEL"] }] }).then(b => { b.send(`${a.author}, please explain your issue here. A <@&989022886801072169> member will be with you shortly. We recommend sending screenshots of the incident you are appealing.`) }) } function report(a) { a.guild.channels.create(`${a.author.tag}-report`, { type: "text", parent: reportsCategory, permissionOverwrites: [{ id: a.guild.roles.everyone, deny: ["VIEW_CHANNEL"] }, { id: a.author.id, allow: ["VIEW_CHANNEL"] }, { id: staffRole, allow: ["VIEW_CHANNEL"] }] }).then(b => { b.send(`${a.author}, please tell us what you wish to report. A <@&989022886801072169> member will be with you shortly. **Please include screenshots if you can**`) }) } function closeChannel(a) { a.channel.name.indexOf("-appeal") > -1 || a.channel.name.indexOf("-report") > -1 ? (a.channel.send("Closing channel..."), setTimeout(() => { a.channel.delete() }, 1e3)) : a.reply({ embeds: [buildEmbed("#2F3136", "Nice try, buddy", "", [], null, !0)] }) } function help(b, a) { switch ("" == b && (b = "1"), b) { case "ban": a.reply({ embeds: [buildEmbed("#2F3136", "Help: Ban", "Bans the specified user", [{ name: "Syntax", value: "```,ban { user } ? { reason }```" },], { text: "Type ,help { command } for more help" }, !0)] }); break; case "unban": a.reply({ embeds: [buildEmbed("#2F3136", "Help: Unban", "Revokes the ban of the specified user", [{ name: "Syntax", value: "```,unban { user }```" },], { text: "Type ,help { command } for more help" }, !0)] }); break; case "mute": a.reply({ embeds: [buildEmbed("#2F3136", "Help: Mute", "Mutes the specified user, removing their permission to send messages", [{ name: "Syntax", value: "```,mute { user } ?{ duration } ?{ reason }```" },], { text: "Type ,help { command } for more help" }, !0)] }); break; case "unmute": a.reply({ embeds: [buildEmbed("#2F3136", "Help: Unmute", "Unmutes specified user", [{ name: "Syntax", value: "```,unmute { user }```" },], { text: "Type ,help { command } for more help" }, !0)] }); break; case "kick": a.reply({ embeds: [buildEmbed("#2F3136", "Help: Kick", "Kicks specified user", [{ name: "Syntax", value: "```,kick { user } ?{ reason }```" },], { text: "Type ,help { command } for more help" }, !0)] }); break; case "warn": a.reply({ embeds: [buildEmbed("#2F3136", "Help: Warn", "Gives a warning to the specified user. Three warnings results in a hour-long mute, and four warnings results in an automatic ban", [{ name: "Syntax", value: "```,warn { user } ?{ message }```" }, { name: "Other commands", value: "`,warn list` | `,warn remove`" }], { text: "Type ,help { command } for more help" }, !0)] }); break; case "all": a.reply({ embeds: [buildEmbed("#2F3136", "Help (1 / 2)", "Moderation commands.", [{ name: "Ban", value: "Bans the specified user." }, { name: "Unban", value: "Unbans the specified user." }, { name: "Kick", value: "Kicks the specified user." }, { name: "Mute", value: "Mutes the specified user." }, { name: "Unmute", value: "Unmutes the specified user." }, { name: "Warn", value: "Gives a warning to the specified user." }, { name: "Clear", value: "Clears the messages in the channel" }, { name: "Delete", value: "Deletes a specific number of messages from the channel" },], { text: "Type ,help { command } for more help" }, !0)] }); break; case "appeal": a.reply({ embeds: [buildEmbed("#2F3136", "Help: Appeal", "Opens a new channel in which you can appeal a staff decision.", [{ name: "Syntax", value: "```,appeal```" },], { text: "Type ,help { command } for more help" }, !0)] }); break; case "report": a.reply({ embeds: [buildEmbed("#2F3136", "Help: Report", "Creates a new channel in which you can report a user.", [{ name: "Syntax", value: "```,report```" },], { text: "Type ,help { command } for more help" }, !0)] }); break; case "clear": a.reply({ embeds: [buildEmbed("#2F3136", "Help: Clear", "Clears the messages in the channel to which the command is sent", [{ name: "Syntax", value: "```,clear```" },], { text: "Type ,help { command } for more help" }, !0)] }); break; case "1": help("all", a); break; case "2": a.reply({ embeds: [buildEmbed("#2F3136", "Help (2 / 2)", "Generic commands.", [{ name: "Report", value: "Open a report channel" }, { name: "Appeal", value: "Appeal a staff decision" }, { name: "Invite", value: "Send the server invite in the current channel" },], { text: "Type ,help { command } for more help" }, !0)] }); break; case "warn-list": a.reply({ embeds: [buildEmbed("#2F3136", "Help: Warn List", "List the warnings the specified user has", [{ name: "Syntax", value: "```,warn list { user }```" },], { text: "Type ,help { command } for more help" }, !0)] }); break; case "warn-remove": a.reply({ embeds: [buildEmbed("#2F3136", "Help: Warn Remove", "Remove a warning from a user's warning list", [{ name: "Syntax", value: "```,warn remove { user } { index }```" },], { text: "Type ,help { command } for more help" }, !0)] }) } } function buildEmbed(d, e, g, a, h, i) { for (var b = 0; b < a.length; b++)a[b].value = "> " + a[b].value; let c = new f().setColor(d).setURL(null).setTitle(e).setDescription(g).setFields(a).setFooter(h); return i || c.setTimestamp(), c } async function potatoGame(a) { let b = a.content.replace(",potato ", "").replace(",p ", "").split(" ")[0].replace("<@", "").replace(">", ""); if (!ableToPlay) { a.reply({ embeds: [buildEmbed("#2F3136", "1 minute must pass between each game.", "", [], null, !0)] }); return } if (potatoChannel !== a.channel.id && "" !== potatoChannel) { a.reply({ embeds: [buildEmbed("#2F3136", "Keep the game in the right channel:", `<#${potatoChannel}>`, [], null, !0)] }); return } if ("" == b) { a.reply({ embeds: [buildEmbed("#2F3136", "You have to pass the potato to someone", "", [], null, !0)] }); return } if (b == client.user.id) { a.reply({ embeds: [buildEmbed("#2F3136", "You can't give me the potato", "", [], null, !0)] }); return } if (potato.previousUser === b) { a.reply({ embeds: [buildEmbed("#2F3136", "You cannot pass the potato to the person who passed it to you", "", [], null, !0)] }); return } if (!a.guild.members.cache.get(b)) { a.reply({ embeds: [buildEmbed("#2F3136", "Not a valid user", "", [], null, !0)] }); return } let c = await a.guild.members.fetch(); if (null === c.get(b).presence || "offline" === c.get(b).presence.status) { a.reply({ embeds: [buildEmbed("#2F3136", "You cannot pass the potato to someone who is offline", "", [], null, !0)] }); return } let d = !1; if (null === potato.currentUser && (potato.currentUser = a.author.id, potatoChannel = a.channel.id, d = !0), potato.currentUser !== a.author.id) { a.reply({ embeds: [buildEmbed("#2F3136", "You do not have the hot potato", "", [], null, !0)] }); return } if (potato.currentUser == b) { a.reply({ embeds: [buildEmbed("#2F3136", "You cannot pass the potato to yourself", "", [], null, !0)] }); return } if (d) { let e = setTimeout(() => { endGame(a.channel) }, 6e3); potato.timer = e, potato.previousUser = a.author.id, potato.currentUser = b, a.channel.send({ embeds: [buildEmbed("#2F3136", "HOT POTATO (1 MINUTE)", `<@${b}> HAS THE POTATO`, [], null, !0)] }).then(() => { a.channel.send(`<@${b}> type ,potato { user } or ,p { user } to pass the potato`) }) } else potato.previousUser = a.author.id, potato.currentUser = b, a.channel.send({ embeds: [buildEmbed("#2F3136", "HOT POTATO", `<@${b}> HAS THE POTATO`, [], null, !0)] }).then(() => { a.channel.send(`<@${b}> type ,potato { user } to pass the potato`) }) } function endGame(b) { ableToPlay = !1, potatoChannel = ""; let a = potato.currentUser, c = client.guilds.cache.get(i).members.cache.get(a); "" !== potatoHead && client.guilds.cache.get(i).members.cache.get(potatoHead).roles.remove(potatoRole), potatoHead = a, client.guilds.cache.get(i).members.cache.get(a).roles.add(potatoRole), b.send({ embeds: [buildEmbed("#2F3136", `The potato was too hot for ${c.user.username}!`, "", [], null, !0)] }).then(() => { potato.currentUser = null, potato.previousUser = null, potato.timer = null }), potatoTimer = setTimeout(() => { ableToPlay = !0 }, 6e4) } function muteTimer(a, b) { this.timer = a, this.user = b } function User(a) { this.id = a, this.messages = [] } function warnMsg(a, b) { this.mod = a, this.msg = b } client.once("ready", () => { client.user.setActivity(",help") }), client.on("guildMemberAdd", a => { client.channels.cache.get("989022003040243723").send(`Everyone welcome ${a} to xOvergang!`), mutedUsers.indexOf(a.id) > -1 && a.roles.add(muteRole) }), client.on("messageCreate", a => { let b = a.content.split(" ")[0]; if ("<@988295746451304489>" === b) { a.reply("What's up?"); return } if (!a.author.bot && "," === b[0]) { if (-1 == commands.indexOf(b) && a.reply({ embeds: [buildEmbed("#2F3136", "I don't recognize that command", "", [], null, !0)] }), modCmds.indexOf(b) > -1 && !a.guild.members.cache.get(a.author.id).roles.cache.get(staffRole)) { a.reply({ embeds: [buildEmbed("#2F3136", "You must be a staff member to use this command", "", [], null, !0)] }); return } if (a.content == b && ",report" !== b && ",appeal" !== b && ",help" !== b && ",invite" !== b && ",clear" !== b && ",close" !== b && ",potato" !== b && ",p" !== b && ",git" !== b) { help(b.replace(",", ""), a); return } switch (b) { case ",help": help(a.content.substring(6, a.content.length), a); break; case ",ban": ban(a); break; case ",unban": unban(a); break; case ",mute": mute(a); break; case ",unmute": unmute(a); break; case ",kick": kick(a); break; case ",warn": warn(a); break; case ",report": report(a); break; case ",appeal": appeal(a); break; case ",invite": invite(a.channel); break; case ",clear": clear(a.channel, a, a.author.tag); break; case ",delete": del(a); break; case ",close": closeChannel(a); break; case ",potato": case ",p": potatoGame(a); break; case ",git": a.reply("https://github.com/isaacmaddox/Discord-Bot") } } }), client.login(c)